# -*- coding: utf-8 -*-
"""RFM Model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xv2uIe0HB5-zx8V5oA0Nb4-Bm0OAiX4y
"""

import pandas as pd
from datetime import datetime as dt, timedelta
import plotly.express as px
import plotly.graph_objects as go
import plotly.colors

df = pd.read_csv('online_retail.csv')

df.head()

df.tail()

df.dropna(subset = ['CustomerID'], inplace = True)

df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
df['Total Amount'] = df['Quantity'] * df['UnitPrice']

df.head()

reference_date = pd.Timestamp(dt.now().date())

reference_date

reference_date = df['InvoiceDate'].max() + timedelta(days=1)

reference_date

rfm = df.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (reference_date - x.max()).days,
    'InvoiceNo': 'count',
    'Total Amount': 'sum'
})

rfm.rename(columns = {
    'InvoiceDate': 'Recency',
    'InvoiceNo': 'Frequency',
    'Total Amount': 'Monetary'
}, inplace = True)

rfm.head()

# Define Quantiles

quantiles = rfm.quantile(q=[0.25, 0.5, 0.75])

# Assign RFM Scores
def RScore(x,p,d):
  if p == 'Recency':
    if x <= d[p][0.25]:
      return 4
    elif x <= d[p][0.5]:
      return 3
    elif x <= d[p][0.75]:
      return 2
    else:
      return 1
  else:
    if x <= d[p][0.25]:
      return 1
    elif x <= d[p][0.5]:
      return 2
    elif x <= d[p][0.75]:
      return 3
    else:
      return 4

rfm['R'] = rfm['Recency'].apply(RScore, args=('Recency', quantiles))
rfm['F'] = rfm['Frequency'].apply(RScore, args=('Frequency', quantiles))
rfm['M'] = rfm['Monetary'].apply(RScore, args=('Monetary', quantiles))

rfm.head()

rfm['RFM_Segment'] = rfm['R'].astype(str) + rfm['F'].astype(str) + rfm['M'].astype(str)
rfm['RFM_Score']= rfm[['R','F','M']].sum(axis=1)

rfm.head()

segment_labels = ['Low-value', 'Mid-value', 'High-value']

def assign_segment(score):
  if score < 5:
    return 'Low-value'
  elif score < 9:
    return 'Mid-value'
  else:
    return 'High-value'

rfm['RFM_Segment_Label'] = rfm['RFM_Score'].apply(assign_segment)

rfm.head()

segment_counts = rfm['RFM_Segment_Label'].value_counts().reset_index()
segment_counts.columns = ['RFM_Segment', 'Count']
segment_counts = segment_counts.sort_values('RFM_Segment')

# Create the bar char using plotly

fig = px.bar(segment_counts,
             x='RFM_Segment',
             y='Count',
             labels={'RFM_Segment': 'RFM Segment', 'Count': 'Number of Customers'},
             color = 'RFM_Segment',
             color_discrete_sequence=px.colors.qualitative.Pastel)
fig.show()

rfm['RFM_Customer_Segments']=''

rfm.loc[rfm['RFM_Score'] >= 9, 'RFM_Customer_Segments'] = 'VIP/Loyal'
rfm.loc[(rfm['RFM_Score'] >= 6) & (rfm['RFM_Score'] < 9), 'RFM_Customer_Segments'] = 'Potential Loyal'
rfm.loc[(rfm['RFM_Score'] >= 5) & (rfm['RFM_Score'] < 6), 'RFM_Customer_Segments'] = 'At Risk'
rfm.loc[(rfm['RFM_Score'] >= 4) & (rfm['RFM_Score'] < 5), 'RFM_Customer_Segments'] = 'Cant Lose'
rfm.loc[(rfm['RFM_Score'] >= 3) & (rfm['RFM_Score'] < 4), 'RFM_Customer_Segments'] = 'Lost'
segment_counts= rfm['RFM_Customer_Segments'].value_counts().reset_index()

segment_product_counts = rfm.groupby(['RFM_Segment_Label', 'RFM_Customer_Segments']).size().reset_index(name='Count')
segment_product_counts = segment_product_counts.sort_values('Count', ascending=False)

# Create the treemap

fig_treemap_segment_product = px.treemap(segment_product_counts,
                                         path=['RFM_Segment_Label', 'RFM_Customer_Segments'],
                                         values='Count',
                                         color='RFM_Segment_Label',
                                         color_discrete_sequence=px.colors.qualitative.Pastel,
                                         title='RFM Customer Segments By Value')
# Display the treemap
fig_treemap_segment_product.show()

vip_segment = rfm[rfm['RFM_Customer_Segments'] == 'VIP/Loyal']

fig = go.Figure()
fig.add_trace(go.Box(y=vip_segment['Recency'], name='Recency'))
fig.add_trace(go.Box(y=vip_segment['Frequency'], name='Frequency'))
fig.add_trace(go.Box(y=vip_segment['Monetary'], name='Monetary'))

correlation_matrix = vip_segment[['R', 'F', 'M']].corr()

fig_heatmap = go.Figure(data=go.Heatmap(
    z=correlation_matrix.values,
    x=correlation_matrix.columns,
    y=correlation_matrix.columns,
    colorscale='RdBu',
    colorbar=dict(title='Correlation')))

fig_heatmap.update_layout(title='Correlation Heatmap')

# Display the heatmap
fig_heatmap.show()

segment_scores = rfm.groupby('RFM_Customer_Segments')[['R','F','M']].mean().reset_index()

fig=go.Figure()

# Add bars for Recency Score
fig.add_trace(go.Bar(
    x=segment_scores['RFM_Customer_Segments'],
    y=segment_scores['R'],
    name = 'Recency Score',
    marker_color = 'rgb(158,202,225)'
))

# Add bars for Frequency Score
fig.add_trace(go.Bar(
    x=segment_scores['RFM_Customer_Segments'],
    y=segment_scores['F'],
    name = 'Frequency Score',
    marker_color = 'rgb(94,158,217)'
))

# Add bars for Monetary Score
fig.add_trace(go.Bar(
    x=segment_scores['RFM_Customer_Segments'],
    y=segment_scores['M'],
    name = 'Monetary Score',
    marker_color = 'rgb(32,102,148)'
))

fig.update_layout(
    title='Comparison of RFM Segments based on Recency, Frequency, and Monetary Scores',
    xaxis_title='RFM Segments',
    yaxis_title='Score',
    barmode='group',
    showlegend=True,
)

fig.show()

